 /***********************************************************************
* FILENAME :        dh_test.c 
*
* DESCRIPTION :
*       Testing the Diffie-Hellman mathematical procedures.
*       It tests if (g^x)^y  == (g^y)^x
*
* 
* AUTHOR :    mraes 
*
*
*****/
 
 
 /* p=2wq+1
  * the generator is of a subgroup of q-1 elements, and q is 160 bits,
  * i.e., recommended key length: 20 bytes 
  */
 #include <stdint.h>
#include "monexp.h"
#include <stdio.h>
#define EXPONENT_LENGTH 2

const unsigned char generator[156] = // generator, Gegeven op toledo
	"\x82\xc1\x57\x1c\xf6\x8d\x59\xaa\xc1\x93\x67\xc7\xde\x23\x4b"
	"\xe8\xc3\xb9\x20\xb8\x36\x2d\x21\xf5\x3e\x3c\x6b\xc8\x4e\xaa"
	"\x5c\x54\x8d\x84\x88\x73\x3a\xc3\x27\x8b\xcf\x66\xe6\x35\xbe"
	"\xbd\x20\x73\x4b\x4b\xea\xaa\x48\x46\xf1\xbc\xf4\x8d\xfa\x0d"
	"\x91\xa3\xbb\xd2\x97\x27\x21\x84\x25\x66\x78\x03\x6d\xd5\x66"
	"\x80\xc5\xa1\x63\x6b\x25\x36\xd7\xe2\x3e\xf6\x6a\xac\x1d\x62"
	"\xb7\xdb\x3c\x6f\xbe\x05\x75\x1b\x1b\x64\x2f\x7c\x1a\xba\x7c"
	"\x07\x4f\x48\x8e\x34\x7b\xf4\xd7\xff\x25\x5f\x2d\x13\x4d\x87"
	"\x4b\x06\x54\x19\x84\xe0\x3d\x61\x14\x4e\x7a\xfb\x12\x38\x34"
	"\x62\x5e\xc0\x33\x7d\xea\xe4\x70\xa6\x79\x9c\x05\x87\xbb\xed"
	"\x9a\xcc\xf1\x0d\xf0\x8b";

const unsigned char prime[156] = // de modulus, gegeven op toledo
	"\xd0\xa8\x73\x80\x04\xa3\x5f\x3d\x10\xf9\x34\x92\x24\xcc\x66"
	"\xb8\xdf\x41\x6e\x9b\x8a\x09\x79\x4d\x69\x35\xf7\x12\xa3\x32"
	"\x46\xc6\x43\x51\xef\x3b\xdb\xad\x21\xcb\xf7\x54\x52\x56\x20"
	"\xcb\x8c\xfa\xcc\x71\x48\xea\xe4\x2b\xfb\x4d\x12\x90\x12\xc6"
	"\xf7\xed\x1f\xee\x95\xa1\x3f\xcc\x95\x78\x74\xcf\x55\x91\xb7"
	"\x9f\x4e\xfc\xe6\x28\x44\x27\x5f\x86\xe1\xde\xf3\x20\xe9\x40"
	"\x07\x90\x24\x00\x7d\x17\xaa\x16\xc1\x9f\xc5\x51\x82\xaa\x5c"
	"\xe0\x42\xac\xe5\x7f\xe9\xaf\xaa\x46\x47\xb6\x76\x80\x3e\x03"
	"\xbc\xe8\xc1\x05\x90\xcc\xd0\x48\x79\xa9\x0e\xab\xcb\x18\x51"
	"\x2a\xa5\xdb\x1c\x6b\xa9\xfc\xd2\xea\x89\xae\xab\xe3\x9c\x3f"
	"\x6b\x03\xc7\x98\xac\x43";
	// these are the rmodn's for the 156 byte modulus (Voor de Diffie Hellman modulus gegeven op toledo)
	uint8_t rmodn_dh[156] = {0xBD,0x53,0x67,0x38,0xFC,0x94,0xC0,0x63,0x1C,0x54,0x51,0x76,0x15,0x2D,0x03,0x56,0x94,0xE3,0x24,0x5A,0xD5,0xAE,0xE7,0x34,0x54,0xF1,0x56,0x86,0xB7,0x2F,0x33,0x6F,0xFA,0x3E,0x17,0x43,0xFC,0xC1,0x7F,0x89,0x49,0xB8,0xB9,0x55,0x50,0x16,0x80,0x1A,0x53,0xBD,0x1F,0xA3,0x55,0x7D,0xAE,0x3A,0x60,0x3E,0xE9,0x55,0xE8,0x82,0xFF,0xDB,0x6F,0xF8,0xBF,0x16,0xDF,0x0C,0x21,0x1E,0x79,0xA0,0xD8,0xBB,0xD7,0x19,0x03,0xB1,0x60,0x48,0x6E,0xAA,0x30,0x8B,0x87,0x6A,0x33,0xC0,0x5E,0x6A,0x11,0xE0,0x12,0x08,0x39,0xED,0x6F,0xED,0xB2,0x04,0xD4,0x1B,0x15,0xB7,0x8E,0x33,0x05,0x73,0x34,0xDF,0xA9,0xAD,0xAB,0x08,0x34,0xDE,0x52,0x24,0xC4,0x10,0xAE,0xBC,0x39,0xB9,0xCD,0x5C,0xED,0x08,0xCA,0x96,0xB2,0x86,0xF6,0x75,0x64,0x91,0xBE,0x20,0x47,0x99,0x33,0xDB,0x6D,0xCB,0x06,0xEF,0xC2,0xA0,0x5C,0xFB,0x7F,0x8C,0x57,0x2F};
	uint8_t r2modn_dh[156] ={0x1A,0x1C,0x3E,0xFD,0x47,0xBE,0x7F,0x6E,0x0C,0xC4,0x25,0xCE,0xEA,0x24,0x25,0x72,0xC5,0x68,0x14,0x23,0x08,0x93,0x2C,0x0C,0x9A,0x84,0x61,0xC0,0x18,0x16,0x27,0x64,0xF0,0x66,0xF7,0x1E,0x23,0xC2,0xEF,0xD3,0x87,0x66,0xB1,0x98,0x82,0x58,0x0C,0x46,0xCB,0x87,0xA7,0x40,0x92,0x94,0x0F,0x76,0x0F,0xA9,0xC6,0x70,0x3B,0x48,0x2B,0x27,0xE6,0xBB,0xA7,0x8E,0xD8,0x5E,0xC2,0x36,0x19,0x3E,0xDF,0x42,0x50,0x78,0x2C,0x2A,0x20,0x27,0x4E,0x60,0x6E,0x9C,0xF9,0x11,0x5E,0xD9,0x1B,0x83,0x56,0x46,0xE4,0x1D,0x93,0xE6,0x5B,0x0C,0xCE,0x4A,0x2B,0xC5,0xAA,0x0F,0xC0,0xED,0x30,0x58,0x77,0xD3,0x45,0xEC,0x71,0xC1,0x32,0xF4,0xEF,0x13,0xD3,0xB6,0x00,0x26,0xE5,0x71,0x4C,0x7D,0x76,0xBB,0x1F,0x0D,0xC6,0x45,0x2F,0x7E,0x07,0xA8,0x49,0xC2,0x20,0x35,0x3B,0x52,0xE7,0xE8,0x51,0x47,0x7A,0xDA,0x1B,0xFB,0xA8,0xE8,0x7C,0x14};
	
	
	int main(){
	signed int i;
	
	uint8_t g[156]; // for storing generator in little endian
	uint8_t p[156]; // for storing prime in little endian
	printf("\n [DH] Generator:\n");
	for(i=155;i>=0;i--){
		g[155-i] = generator[i];
		printf("0x%02X,",g[155-i]);
	}
	printf("\n [DH] Prime:\n");
	for(i=155;i>=0;i--){
		p[155-i] = prime[i];
		printf("0x%02X,",p[155-i]);
	}
	printf("\nPrime IN MAPLE FORMAT:\n");
	for(i=155;i>=0;i--){
		printf("%02X",p[i]);
	}
	
	uint8_t e1[EXPONENT_LENGTH]= {0x01,0x03}; // exponent1 (random number)
	uint8_t e2[EXPONENT_LENGTH]= {0x05,0x01}; // exponent2 (random number)
	uint8_t res1[156];
	uint8_t final1[156];
	montgomery_exponentiation(res1,g,e1,EXPONENT_LENGTH,p,rmodn_dh,r2modn_dh); // now res1 contains g to the power e1
	montgomery_exponentiation(final1,res1,e2,EXPONENT_LENGTH,p,rmodn_dh,r2modn_dh); // now final1 contains g to the power e1 to the power e2
	printf("\n[DH] FINAL1\n");
	for(i=0;i<156;i++){
		printf("0x%02X,",final1[i]);
	}
	uint8_t res2[156];
	uint8_t final2[156];
	montgomery_exponentiation(res2,g,e2,EXPONENT_LENGTH,p,rmodn_dh,r2modn_dh); // now res1 contains g to the power e2
	montgomery_exponentiation(final2,res2,e1,EXPONENT_LENGTH,p,rmodn_dh,r2modn_dh); // now final2 contains g to the power e2 to the power e1
	printf("\n[DH] FINAL2\n");
	for(i=0;i<156;i++){
		printf("0x%02X,",final2[i]);
	}
	
	for(i=0;i<156;i++){
		if(final1[i] != final2[i]){
			printf("\n FINAL1 NOT EQUAL TO FINAL2\n"); // If the two computations are not equal, this will print.
			break;
		}
	}
	
	printf("\n");
	return 0;
	}