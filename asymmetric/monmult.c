/***********************************************************************
* FILENAME :        monmult.c          VERSION: 1.0
*
* DESCRIPTION :
*       Performs Montgomery Multiplication of 2 multiple precision integers.
*
* PUBLIC FUNCTIONS :
*       int     monmult(  )
*
* NOTES : Using the Finely Integrated Product Scanning (FIPS) algorithm.
* 
* AUTHOR :    mraes        START DATE :    10 Mar 16
*
*
*****/
#include <stdint.h>
#include <stdio.h>
#define SIZE 128
#define MWORDSIZE 8
#define USE_TOLEDO_TESTVECTORS 0

#if USE_TOLEDO_TESTVECTORS
uint8_t a[SIZE] = {0x6A, 0xA1, 0xB7, 0xCD, 0x05, 0x40, 0xE3, 0x1E, 0x86, 0x71, 0x2D, 0xE6, 0xDE, 0x60, 0x49, 0xD5, 0x14, 0x40, 0x26, 0x45,};
uint8_t b[SIZE] = {0x08, 0xB4, 0xBA, 0x7F, 0xD3, 0xB5, 0x82, 0x61, 0x79, 0x4F, 0x76, 0x2A, 0x42, 0x9C, 0xBC, 0x12, 0xFD, 0x8E, 0xB7, 0x76,};
uint8_t n[SIZE] = {0x27, 0x20, 0xAF, 0x37, 0x3F, 0x6F, 0xB1, 0xB2, 0x7F, 0x38, 0xE6, 0x2C, 0x79, 0xB0, 0x43, 0xC5, 0x1A, 0x28, 0x8E, 0x99,};
#else 
//input
uint8_t a[SIZE] = {0xA3,0x71,0x79,0x01,0xFC,0xF2,0x93,0xC7,0x1C,0x69,0x2D,0x67,0x38,0x2B,0x7C,0x1A,0x40,0x88,0xBA,0x9B,0x10,0x53,0x65,0xED,0xFE,0x39,0xB4,0x77,0x3B,0xC8,0x9B,0xB2,0xE4,0xB1,0xA3,0xC9,0xCD,0xC8,0xF2,0x69,0x01,0x91,0x87,0x67,0xAC,0x6E,0x56,0xF1,0x60,0xBF,0x1E,0x0F,0x53,0xA8,0xAF,0x40,0xDB,0x76,0xB2,0xEA,0x90,0xDD,0xFF,0x40,0x0C,0xD2,0x4D,0xDC,0x5E,0xB3,0xE7,0xFA,0xB4,0x53,0x5E,0x75,0x0B,0x91,0x92,0x14,0x7E,0xD8,0xB8,0xA7,0x05,0x95,0xD0,0x55,0x97,0x30,0x78,0x41,0x81,0xEF,0xC6,0x64,0x9F,0x4A,0x9C,0x4A,0x3A,0x0B,0xCA,0xD8,0x9C,0x1A,0x64,0xA7,0xA9,0x6E,0xC8,0x0A,0xE5,0xCE,0xE2,0x3B,0x73,0x8A,0xEF,0xF0,0xE4,0xA6,0x40,0x26,0xF3,0xD9,0x50,0x1F};

uint8_t b[SIZE] = {0xBD,0xAA,0x18,0x4C,0xCD,0x5C,0x95,0x35,0x5B,0xA2,0x9D,0xC0,0xEB,0xE2,0x8A,0xC6,0xBF,0xDF,0xA1,0x88,0x1B,0x8C,0x58,0xE3,0xB0,0xD8,0xF8,0xC6,0xB6,0x01,0x96,0xE2,0xE0,0x52,0x01,0x0B,0x3A,0xFF,0x65,0x48,0xE0,0x67,0xCD,0x9E,0x1E,0x6A,0xA4,0xFC,0x04,0xC5,0x7B,0x1C,0xF0,0x2B,0xD1,0x4E,0x62,0xFB,0x36,0x68,0xB9,0x70,0xC8,0x98,0x0C,0x8A,0x65,0x3C,0xD1,0x15,0x2B,0x13,0xCA,0x5A,0xB7,0xBA,0xFC,0x15,0x37,0x11,0x6C,0xF3,0x93,0x85,0x9B,0x1E,0xE8,0x28,0x44,0x4B,0xFB,0x6A,0xFD,0xEC,0xC9,0xCB,0xC9,0x07,0x28,0x2B,0x96,0xE0,0xF9,0xA5,0x8C,0x35,0x62,0xCC,0xAB,0xB9,0xF3,0xA2,0xA9,0x4D,0x24,0x07,0x16,0x87,0xF4,0x31,0xBB,0xBC,0x6D,0x0A,0x88,0xE5,0x47,0x7D};

uint8_t c[SIZE] = {0x0C,0xEC,0x99,0xE6,0x55,0x5E,0x18,0x12,0x7C,0xA1,0xAF,0x34,0xA7,0x53,0x1A,0x95,0xED,0x9C,0x70,0xF8,0x9F,0x70,0xB7,0xE0,0x79,0xF2,0xAE,0x8B,0x88,0xD2,0xC4,0xB8,0xB7,0x6F,0x0C,0xCC,0x2E,0xC9,0x5C,0xB8,0x82,0x0E,0x7B,0x17,0xE1,0xC3,0x0A,0x32,0x35,0xDB,0x5C,0xBE,0xAC,0x35,0xD3,0x0B,0xEE,0xE5,0x8A,0x77,0x89,0xC0,0xBC,0x4D,0xD3,0x3E,0x5B,0x8E,0xA8,0xD5,0x06,0x0E,0x17,0x7A,0x5E,0x1D,0xD2,0x1C,0xC5,0xE4,0x19,0x55,0x1D,0x1A,0x4A,0x57,0xAC,0xAF,0x0F,0xF0,0xDD,0xA2,0xFE,0xF3,0x7E,0x8B,0xAA,0x15,0xB5,0xA3,0x2A,0x4A,0x70,0xCB,0x60,0x09,0xD3,0xBA,0x22,0x47,0x68,0xBC,0x96,0x17,0xBD,0xB8,0x39,0xCA,0xA5,0x57,0x16,0x12,0x95,0x89,0x9F,0x80,0x22,0x8C};

uint8_t n[SIZE] = {0x0D,0xD5,0x0F,0x26,0x8F,0x95,0xAD,0x59,0x24,0xA0,0xDA,0x8F,0xAE,0x27,0x9F,0xD4,0x7A,0xE7,0x7E,0xBF,0xDF,0x2D,0x12,0xDA,0x43,0x14,0x0F,0x20,0xFA,0x90,0x46,0xD5,0x39,0xF1,0xAA,0x90,0x02,0xE4,0xDC,0xA3,0x9C,0xA4,0xF2,0xFF,0x30,0xC1,0x14,0x22,0x7E,0x11,0xE3,0x77,0x00,0x1A,0xAD,0x50,0xE1,0x7B,0x91,0x4A,0x92,0x08,0x65,0x20,0x75,0x68,0x74,0xB3,0x65,0xB0,0x0C,0xC6,0x8B,0xC9,0x10,0xEF,0xC4,0x4E,0x45,0xAD,0xFA,0xD2,0x4F,0x06,0xEC,0x29,0x5C,0xF3,0xAA,0x97,0x82,0x70,0xB8,0x44,0x06,0x86,0xE0,0x67,0xFC,0x70,0x79,0xA4,0xF0,0xB3,0x0B,0x48,0xCD,0xF0,0x6C,0x6F,0x0B,0x8B,0x25,0x67,0x46,0x8F,0xEC,0xA4,0xC1,0xE3,0x6A,0x47,0x0D,0xEB,0xA3,0x81,0xB5,0xBA};

uint8_t nprime[SIZE] = {0x3B,0xFE,0x13,0x49,0x55,0x1C,0x95,0x10,0x74,0x60,0xFA,0xE6,0x25,0x4B,0x97,0x8A,0x34,0x92,0x37,0x72,0xAE,0x1B,0x7D,0xCE,0x9D,0x5F,0xEC,0x6C,0x13,0x0E,0xFE,0xC7,0xB3,0xD4,0xB4,0x03,0x4C,0x8B,0xAE,0x0D,0x86,0xDC,0x65,0x06,0xC4,0xBB,0x5D,0x15,0xBE,0x76,0x26,0x08,0x57,0x60,0xD8,0x83,0x76,0x38,0x1C,0xDE,0x3B,0x16,0x94,0x2D,0xCC,0xA5,0x8B,0x45,0x2D,0x32,0x87,0x12,0x18,0x99,0xDE,0x4C,0x2B,0x16,0x24,0xFA,0x2A,0x69,0x04,0x9C,0xE8,0xF3,0x2B,0x08,0x79,0xA8,0xC6,0xED,0xB8,0xD8,0x1A,0x45,0x57,0x0C,0x40,0xD7,0x37,0xA6,0x19,0xCD,0x5A,0x56,0xDE,0xF6,0x29,0xDB,0x15,0x5A,0x0B,0x48,0x43,0x36,0xED,0xFD,0xBD,0x90,0x35,0x81,0x3B,0xA3,0x18,0x54,0xB1,0xD7};

#endif

// NEED TO CHANGE SHIFTING AND MASKING (from >>8 to >>16 for example and from && xff to &&xffff)!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
uint16_t a16[SIZE] = {0x71A3,0x179,0xF2FC,0xC793,0x691C,0x672D,0x2B38,0x1A7C,0x8840,0x9BBA,0x5310,0xED65,0x39FE,0x77B4,0xC83B,0xB29B,0xB1E4,0xC9A3,0xC8CD,0x69F2,0x9101,0x6787,0x6EAC,0xF156,0xBF60,0xF1E,0xA853,0x40AF,0x76DB,0xEAB2,0xDD90,0x40FF,0xD20C,0xDC4D,0xB35E,0xFAE7,0x53B4,0x755E,0x910B,0x1492,0xD87E,0xA7B8,0x9505,0x55D0,0x3097,0x4178,0xEF81,0x64C6,0x4A9F,0x4A9C,0xB3A,0xD8CA,0x1A9C,0xA764,0x6EA9,0xAC8,0xCEE5,0x3BE2,0x8A73,0xF0EF,0xA6E4,0x2640,0xD9F3,0x1F50};

uint16_t b16[SIZE] = {0xAABD,0x4C18,0x5CCD,0x3595,0xA25B,0xC09D,0xE2EB,0xC68A,0xDFBF,0x88A1,0x8C1B,0xE358,0xD8B0,0xC6F8,0x1B6,0xE296,0x52E0,0xB01,0xFF3A,0x4865,0x67E0,0x9ECD,0x6A1E,0xFCA4,0xC504,0x1C7B,0x2BF0,0x4ED1,0xFB62,0x6836,0x70B9,0x98C8,0x8A0C,0x3C65,0x15D1,0x132B,0x5ACA,0xBAB7,0x15FC,0x1137,0xF36C,0x8593,0x1E9B,0x28E8,0x4B44,0x6AFB,0xECFD,0xCBC9,0x7C9,0x2B28,0xE096,0xA5F9,0x358C,0xCC62,0xB9AB,0xA2F3,0x4DA9,0x724,0x8716,0x31F4,0xBCBB,0xA6D,0xE588,0x7D47};

uint16_t c16[SIZE] = {0xEC0C,0xE699,0x5E55,0x1218,0xA17C,0x34AF,0x53A7,0x951A,0x9CED,0xF870,0x709F,0xE0B7,0xF279,0x8BAE,0xD288,0xB8C4,0x6FB7,0xCC0C,0xC92E,0xB85C,0xE82,0x177B,0xC3E1,0x320A,0xDB35,0xBE5C,0x35AC,0xBD3,0xE5EE,0x778A,0xC089,0x4DBC,0x3ED3,0x8E5B,0xD5A8,0xE06,0x7A17,0x1D5E,0x1CD2,0xE4C5,0x5519,0x1A1D,0x574A,0xAFAC,0xF00F,0xA2DD,0xF3FE,0x8B7E,0x15AA,0xA3B5,0x4A2A,0xCB70,0x960,0xBAD3,0x4722,0xBC68,0x1796,0xB8BD,0xCA39,0x57A5,0x1216,0x8995,0x809F,0x8C22};

uint16_t n16[SIZE] = {0xD50D,0x260F,0x958F,0x59AD,0xA024,0x8FDA,0x27AE,0xD49F,0xE77A,0xBF7E,0x2DDF,0xDA12,0x1443,0x200F,0x90FA,0xD546,0xF139,0x90AA,0xE402,0xA3DC,0xA49C,0xFFF2,0xC130,0x2214,0x117E,0x77E3,0x1A00,0x50AD,0x7BE1,0x4A91,0x892,0x2065,0x6875,0xB374,0xB065,0xC60C,0xC98B,0xEF10,0x4EC4,0xAD45,0xD2FA,0x64F,0x29EC,0xF35C,0x97AA,0x7082,0x44B8,0x8606,0x67E0,0x70FC,0xA479,0xB3F0,0x480B,0xF0CD,0x6F6C,0x8B0B,0x6725,0x8F46,0xA4EC,0xE3C1,0x476A,0xEB0D,0x81A3,0xBAB5};

uint16_t nprime16[SIZE] = {0xFE3B,0x4913,0x1C55,0x1095,0x6074,0xE6FA,0x4B25,0x8A97,0x9234,0x7237,0x1BAE,0xCE7D,0x5F9D,0x6CEC,0xE13,0xC7FE,0xD4B3,0x3B4,0x8B4C,0xDAE,0xDC86,0x665,0xBBC4,0x155D,0x76BE,0x826,0x6057,0x83D8,0x3876,0xDE1C,0x163B,0x2D94,0xA5CC,0x458B,0x322D,0x1287,0x9918,0x4CDE,0x162B,0xFA24,0x692A,0x9C04,0xF3E8,0x82B,0xA879,0xEDC6,0xD8B8,0x451A,0xC57,0xD740,0xA637,0xCD19,0x565A,0xF6DE,0xDB29,0x5A15,0x480B,0x3643,0xFDED,0x90BD,0x8135,0xA33B,0x5418,0xD7B1};

// output
uint8_t result_mon_mul[2*SIZE];

// Global internal RAM (chosen by the compiler by default)
unsigned char i;

// Computes x**-1 mod b for x odd and b being 2**(8)
// x begin ODD is REQUIRED and assumed in this function.
// For its normal use (inverting the least significant word of the modulus, this is normally fulfilled because the modulus has to be odd.
// Based on algorithm found in "A Cryptographic Library for the Motorola DSP56000"
uint8_t mod_inverse(uint8_t x)
{
	uint8_t y[MWORDSIZE+1] = {0,1,};
	uint16_t bitmask = 0;
	for(i=2;i<MWORDSIZE+1;i++){
		bitmask = 0xFFFF;      //1111111111111111
		bitmask = bitmask << i;//1111111111111100
		bitmask = ~bitmask;    //0000000000000011 to select the last 2 bits, which is the same as doing modulo 2**2
		//fprintf(stdout,"Bitmask is 0x%02X\n", bitmask);
			if((x*y[i-1] & bitmask) < (0x0001) << (i-1) ){ 
				
				y[i] = y[i-1];
			}else{
				y[i] = y[i-1] + ((0x01) << (i-1));
			}
		//fprintf(stdout,"y[%0d] is %0d\n", i, y[i]);
	}
	
	return y[MWORDSIZE];
}
void montgomery_multiplication(uint8_t *res, uint8_t *in1, uint8_t *in2)
{
	// You can use n and nprime directly as global variables, i.e. without passing them as pointers

	// NEED nprime is toch n accent he? wat is r dan? 

	// inputs: a,b (mod n), n, n'
	// step numbers are defined as in paper on page 2

	// STEP 1: t = a.b & STEP 2 integrated
	
		// loop variables
		unsigned short k;
		unsigned char j;

		// temporary sum used in former ADD function
		unsigned short temp_sum = 0;

		// variables used in former mp_substraction function
		unsigned short s1;
		unsigned short s2;
		signed short r = 0;
		unsigned short c = 0;

		// resetting t to zeros array TODO needed? 
		// NEED opmerking onderaan pagina 8 over dimensie van t!
		uint8_t t[3]={0x0,0x0,0x0};
		// variable for storing m as well as u
		uint8_t m[SIZE];
		// sum in short (C,S)
		unsigned short S_short = 0;
		// sum S
		uint8_t S = 0;
		// carry C
		uint8_t C = 0;

		uint8_t min_n0 = (-n[0]) & 0xFF;
		fprintf(stdout,"min_n0 is 0x%02X, in decimal (unsigned) : %0d\n", min_n0,min_n0);
		uint8_t nprime_0 = mod_inverse(min_n0);
		fprintf(stdout,"nprime_0 is 0x%02X, in decimal (unsigned) : %0d\n", nprime_0 ,nprime_0);

		for(k=0; k<SIZE; k++)
		{
			for(j=0; j<k; j++) //deze loop wordt bij de eerste iteratie van i niet uitgevoerd
			{
				// (C,S) = t[0] + a[j]*b[i-j]
					// multiplication of two chars results in short
					S_short = t[0] + in1[j]*in2[k-j];
					// S_short can be split in first char=C, second char=S
					C = (S_short >> (8)) & 0xff;
					S = S_short & 0xff; // TODO moet hier cast (char)?

				// add carry C to t[1] and propagate carry if needed
					// carry is second char of short
					t[2] += (t[1] + C) >> 8;
					// actual sum is first char of short
					t[1] = t[1] + C;

				// (C,S) = S + m[j]*n[i-j]
					// multiplication of two chars results in short
					S_short = S + m[j]*n[k-j];
					// S_short can be split in first char=C, second char=S
					C = (S_short >> (8)) & 0xff;
					S = S_short & 0xff; // TODO moet hier cast (char)?

				t[0] = S;

				// add carry C to t[1] and propagate carry if needed
					// carry is second char of short
					t[2] += (t[1] + C) >> 8;
					// actual sum is first char of short
					t[1] = t[1] + C;
			}

			// (C,S) = t[0] + a[i]*b[0]
					// multiplication of two chars results in short
					S_short = t[0] + in1[k]*in2[0];
					// S_short can be split in first char=C, second char=S
					C = (S_short >> 8) & 0xff;
					S = S_short & 0xff; // TODO moet hier cast (char)?

			// add carry C to t[1] and propagate carry if needed
				// carry is second char of short
				t[2] += (t[1] + C) >> 8;
				// actual sum is first char of short
				t[1] = t[1] + C;

			// m[i] = S*nprime[0] mod W
			// W = 2**w(ordsize) =256 als w=8
			// W is te interpreteren als de nieuwe radix van deze mp bewerking
			// w = 8 bit 
			// module 2**8 is het zelfde als shiften met 8 als de input een 16 bit getal is (short=char*char)
			//  & 0xff is niet nodig, maar weglaten speed code niet up
			// initiele code m[i] = ((S*nprime[0]) >> 8) & 0xff;
			// ik denk dat shiften niet nodig is want je wil de LSB houden
			m[k] = (S*nprime_0) & 0xff;

			// (C,S) = S + m[i]*n[0]
					// multiplication of two chars results in short
					S_short = S + m[k]*n[0];
					// S_short can be split in first char=C, second char=S
					C = (S_short >> 8) & 0xff;
					S = S_short & 0xff; // TODO moet hier cast (char)?

			// add carry C to t[1] and propagate carry if needed
				// carry is second char of short
				t[2] += (t[1] + C) >> 8;
				// actual sum is first char of short
				t[1] = t[1] + C;

			// een soort t shift
			t[0] = t[1];
			t[1] = t[2];
			t[2] = 0;
		}

	// STEP 2 finishing touch

		for(k=SIZE; k<2*SIZE; k++) // NEED warning: comparison is always true due to limited range of data type. warning is er niet meer omdat i nu short is ipv char
		{
			for(j=k-SIZE+1; j<SIZE; j++)
			{
				// (C,S) = t[0] + a[j]*b[i-j]
					// multiplication of two chars results in short
					S_short = t[0] + in1[j]*in2[k-j];
					// S_short can be split in first char=C, second char=S
					C = (S_short >> 8) & 0xff;
					S = S_short & 0xff; // TODO moet hier cast (char)?

				// add carry C to t[1] and propagate carry if needed
					// carry is second char of short
					t[2] += (t[1] + C) >> 8;
					// actual sum is first char of short
					t[1] = t[1] + C;

				// (C,S) = S + m[j]*n[i-j]
					// multiplication of two chars results in short
					S_short = S + m[j]*n[k-j];
					// S_short can be split in first char=C, second char=S
					C = (S_short >> 8) & 0xff;
					S = S_short & 0xff; // TODO moet hier cast (char)?

				t[0] = S;
				
				// add carry C to t[1] and propagate carry if needed
					// carry is second char of short
					t[2] += (t[1] + C) >> 8;
					// actual sum is first char of short
					t[1] = t[1] + C;
			}

			m[k-SIZE] = t[0];

			// een soort t shift
			t[0] = t[1];
			t[1] = t[2];
			t[2] = 0;
		}

	// STEP 3: substraction if needed
	// if u>=n then return u-n else return u
	// m = u!

		// kaascode
		// GEEN NIEUWE VARS DECLAREREN MIDDEN IN FUNCTIE! hier geen unsigned char k=0; meer declareren!
		k=0;
		// TODO for met break ipv while?
		while(m[SIZE-1-k] == n[SIZE-k-i]) //Search for the first two words that are different, starting from MSB
		{ 
			k++;
		}
		
		if(m[SIZE-1-k] >= n[SIZE-1-k])
		{
			// mp_substraction(m,m,n)
			for(j=0; j<SIZE; j++)
			{
				s1 = (short) m[j];
				s2 = (short) n[j];
				r = s1 - s2 - c;
				if(r < 0)
				{ 
					c = 1;
					r = r + (SIZE + SIZE); // r mod(2*SIZE) (always: |r|<2*SIZE)
				}
				else
				{
					c = 0;		
				}
				m[j] = (unsigned char) r&0xff;
			}
			m[j] = (unsigned char) (SIZE-c); // modulo NEED kaas wat is dit? en klopt het zoals ik het nu doe? 
		}

	// assign output
	// memcpy is niet sneller, maar werkt wel!
	// copy zelfs helemaal niet nodig als m op de plaats van res in het geheugen wordt genomen
	// als je dit echter verwijderd, verslechtert de tijd! (compiler doet rare dingen, houdt m lokaal of zo?)
	for(k=0; k<SIZE; k++)
	{
		res[k]=m[k];	
	}

}

int main() 
{
	montgomery_multiplication(result_mon_mul,a,b);
	printf("Result of monmult is:\n");
	for(i=0; i<SIZE; i++)
	{
		fprintf(stdout,"0x%02X,", result_mon_mul[i]);
	}
	/*int it;
	for(it=SIZE-1; it>=0; it--)
	{
		fprintf(stdout,"0x%02X, ", n[it]);

	}*/ 
		printf("\n");
	return 0;
}

